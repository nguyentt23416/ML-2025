# Code generated by TkForge <https://github.com/axorax/tkforge>
# Donate to support TkForge! <https://www.patreon.com/axorax>

import os
import sys
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.preprocessing import LabelEncoder
import warnings
import subprocess

warnings.filterwarnings('ignore')


def load_asset(path):
    base = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    assets = os.path.join(base, "assets")
    return os.path.join(assets, path)


class PredictionApp:
    def __init__(self, window):
        self.window = window
        self.window.geometry("1280x720")
        self.window.configure(bg="#ffffff")
        self.window.title("Machine Learning UI")

        self.current_dataset = None
        self.dataset_info = None
        self.model = None
        self.X_train = None
        self.X_test = None
        self.y_train = None
        self.y_test = None
        self.predictions = None
        self.label_encoders = {}
        self.target_col = ""

        # Store image references to prevent garbage collection
        self.images = {}

        self.setup_ui()

    def setup_ui(self):
        self.canvas = tk.Canvas(
            self.window,
            bg="#ffffff",
            width=1280,
            height=720,
            bd=0,
            highlightthickness=0,
            relief="ridge"
        )
        self.canvas.place(x=0, y=0)

        # Load and store background images
        self.images['image_4'] = tk.PhotoImage(file=load_asset("frame_1/1.png"))
        self.images['image_5'] = tk.PhotoImage(file=load_asset("frame_1/2.png"))

        # Create background images on canvas
        self.canvas.create_image(640, 360, image=self.images['image_4'])
        self.canvas.create_image(822, 406, image=self.images['image_5'])

        # Frame for table display (replaces textarea_8)
        self.table_frame = tk.Frame(
            self.window,
            bg="#000000",
            width=566,
            height=411
        )
        self.table_frame.place(x=234, y=217)
        self.table_frame.pack_propagate(False)

        # Create treeview for table
        self.tree = None
        self.tree_scroll_y = None
        self.tree_scroll_x = None

        # Select Dataset button
        self.images['button_select'] = tk.PhotoImage(file=load_asset("frame_1/3.png"))
        self.button_select = tk.Button(
            image=self.images['button_select'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=self.select_dataset
        )
        self.button_select.place(x=234, y=145, width=140, height=23)

        # Dataset path display - WILL SHOW IN RED WHEN SELECTED
        self.textbox_1 = tk.Entry(
            bd=0,
            bg="#000000",
            fg="#ffffff",  # Default color
            insertbackground="#ffffff",
            highlightthickness=0,
            font=("Arial", 10),
            justify='center'
        )
        self.textbox_1.place(x=375, y=145, width=424, height=26)
        self.textbox_1.insert(0, "No dataset selected")  # Default text

        # Training rate button
        self.images['button_trainrate'] = tk.PhotoImage(file=load_asset("frame_1/4.png"))
        self.button_trainrate = tk.Button(
            image=self.images['button_trainrate'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=self.show_training_rate
        )
        self.button_trainrate.place(x=235, y=180, width=139, height=24)

        # Train button
        self.images['button_train'] = tk.PhotoImage(file=load_asset("frame_1/5.png"))
        self.button_train = tk.Button(
            image=self.images['button_train'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=self.train_model
        )
        self.button_train.place(x=512, y=180, width=141, height=24)

        # Evaluate button
        self.images['button_evaluate'] = tk.PhotoImage(file=load_asset("frame_1/8.png"))
        self.button_evaluate = tk.Button(
            image=self.images['button_evaluate'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=self.evaluate_model
        )
        self.button_evaluate.place(x=659, y=180, width=141, height=24)

        # Training rate input - CLEARED INITIALLY
        self.textbox_2 = tk.Entry(
            bd=0,
            bg="#000000",
            fg="#FFFFFF",
            insertbackground="#FFFFFF",
            highlightthickness=0,
            font=("Arial", 12)
        )
        self.textbox_2.place(x=375, y=177, width=130, height=28)
        self.textbox_2.insert(0, "0.8")  # Default training rate

        self.canvas.create_text(
            853,
            177,
            anchor="nw",
            text="Evaluation",
            fill="#ffffff",
            font=("Roboto", 32 * -1)
        )

        # Navigation functions
        def open_statistic():
            self.window.destroy()
            subprocess.Popen([sys.executable, "statistic.py"])

        def open_management():
            self.window.destroy()
            subprocess.Popen([sys.executable, "management.py"])

        def open_login():
            self.window.destroy()
            subprocess.Popen([sys.executable, "login.py"])

        def open_prediction():
            # Already in prediction, do nothing
            pass

        # Navigation buttons
        self.images['button_logout'] = tk.PhotoImage(file=load_asset("frame_2/2.png"))
        self.button_logout = tk.Button(
            image=self.images['button_logout'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=open_login
        )
        self.button_logout.place(x=37, y=538, width=116, height=116)

        # Results text area - CLEARED INITIALLY
        self.textarea_9 = tk.Text(
            bd=0,
            bg="#000000",
            fg="#FFFFFF",
            insertbackground="#FFFFFF",
            highlightthickness=0,
            font=("Consolas", 10)
        )
        self.textarea_9.place(x=853, y=217, width=412, height=261)

        self.images['button_prediction'] = tk.PhotoImage(file=load_asset("frame_2/3.png"))
        self.button_prediction = tk.Button(
            image=self.images['button_prediction'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=open_prediction
        )
        self.button_prediction.place(x=38, y=372, width=116, height=116)

        self.images['button_management'] = tk.PhotoImage(file=load_asset("frame_2/4.png"))
        self.button_management = tk.Button(
            image=self.images['button_management'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=open_management
        )
        self.button_management.place(x=37, y=210, width=116, height=116)

        self.images['button_dashboard'] = tk.PhotoImage(file=load_asset("frame_1/12.png"))
        self.button_dashboard = tk.Button(
            image=self.images['button_dashboard'],
            relief="flat",
            borderwidth=0,
            highlightthickness=0,
            command=open_statistic
        )
        self.button_dashboard.place(x=37, y=44, width=116, height=116)

        # Navigation labels
        self.canvas.create_text(
            41,
            666,
            anchor="nw",
            text="Log Out",
            fill="#ffffff",
            font=("Roboto", 14 * -1)
        )

        self.canvas.create_text(
            42,
            499,
            anchor="nw",
            text="ML Prediction",
            fill="#ffffff",
            font=("Roboto", 14 * -1)
        )

        self.canvas.create_text(
            40,
            338,
            anchor="nw",
            text="Product Management",
            fill="#ffffff",
            font=("Roboto", 14 * -1)
        )

        self.canvas.create_text(
            40,
            171,
            anchor="nw",
            text="Dashboard",
            fill="#ffffff",
            font=("Roboto", 14 * -1)
        )

        self.canvas.create_text(
            439,
            29,
            anchor="nw",
            text="PREDICTION",
            fill="#ffffff",
            font=("Rubik One", 64 * -1)
        )

        # Initialize with cleared areas
        self.clear_all_areas()

    # ... (rest of the PredictionApp class methods remain the same)
    # Only the navigation parts were modified above

    def clear_all_areas(self):
        """Clear all areas and set default states"""
        # Clear table area
        self.clear_table_area()

        # Clear results textarea
        self.textarea_9.delete(1.0, tk.END)

        # Reset dataset path to default
        self.textbox_1.delete(0, tk.END)
        self.textbox_1.insert(0, "No dataset selected")
        self.textbox_1.config(fg="#ffffff")  # Reset to white color

    def clear_table_area(self):
        """Clear the table area"""
        if self.tree:
            self.tree.destroy()
            self.tree = None
        if self.tree_scroll_y:
            self.tree_scroll_y.destroy()
            self.tree_scroll_y = None
        if self.tree_scroll_x:
            self.tree_scroll_x.destroy()
            self.tree_scroll_x = None

        # Clear any existing widgets in table frame
        for widget in self.table_frame.winfo_children():
            widget.destroy()

    def get_dataset_folder(self):
        """Get the dataset folder path"""
        current_dir = os.path.dirname(os.path.abspath(__file__))
        dataset_folder = os.path.join(current_dir, "dataset")
        return dataset_folder

    def select_dataset(self):
        """Open file dialog to select a dataset from the dataset folder"""
        print("Select dataset button clicked!")  # Debug
        dataset_folder = self.get_dataset_folder()
        print(f"Dataset folder: {dataset_folder}")  # Debug

        # Create dataset folder if it doesn't exist
        if not os.path.exists(dataset_folder):
            os.makedirs(dataset_folder)
            messagebox.showinfo("Info", f"Created dataset folder at: {dataset_folder}")

        # Get all CSV files in dataset folder
        csv_files = [f for f in os.listdir(dataset_folder) if f.endswith('.csv')]
        print(f"Found CSV files: {csv_files}")  # Debug

        if not csv_files:
            messagebox.showwarning("Warning", "No CSV files found in dataset folder!")
            return

        # Create selection dialog
        print("Creating selection dialog...")  # Debug
        self.create_dataset_selection_dialog(csv_files)

    def create_dataset_selection_dialog(self, csv_files):
        """Create a dialog to select from available datasets"""
        try:
            print(f"Creating dialog with files: {csv_files}")
            selection_window = tk.Toplevel(self.window)
            selection_window.title("Select Dataset")
            selection_window.geometry("400x300")
            selection_window.configure(bg="#2c2c2c")
            selection_window.transient(self.window)
            selection_window.grab_set()

            # Make sure window is focused and on top
            selection_window.focus_set()
            selection_window.lift()

            # Center the window
            selection_window.update_idletasks()
            x = (self.window.winfo_screenwidth() // 2) - (400 // 2)
            y = (self.window.winfo_screenheight() // 2) - (300 // 2)
            selection_window.geometry(f"400x300+{x}+{y}")

            # Add title
            title_label = tk.Label(
                selection_window,
                text="Select a dataset:",
                bg="#2c2c2c",
                fg="white",
                font=("Arial", 14, "bold")
            )
            title_label.pack(pady=10)

            # Create frame for listbox and scrollbar
            list_frame = tk.Frame(selection_window, bg="#2c2c2c")
            list_frame.pack(padx=20, pady=10, fill=tk.BOTH, expand=True)

            # Listbox for datasets
            listbox = tk.Listbox(
                list_frame,
                bg="#1a1a1a",
                fg="white",
                selectbackground="#4CAF50",
                font=("Arial", 11),
                height=8
            )
            listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            # Scrollbar for listbox
            scrollbar = tk.Scrollbar(list_frame, orient=tk.VERTICAL, command=listbox.yview)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            listbox.config(yscrollcommand=scrollbar.set)

            # Add datasets to listbox
            for csv_file in csv_files:
                listbox.insert(tk.END, csv_file)

            # Select the first item by default
            if csv_files:
                listbox.selection_set(0)
                listbox.activate(0)

            # Select button
            def load_selected_dataset():
                selection = listbox.curselection()
                if selection:
                    selected_file = listbox.get(selection[0])
                    print(f"Selected file: {selected_file}")
                    self.load_dataset_file(selected_file)
                    selection_window.destroy()
                else:
                    messagebox.showwarning("Warning", "Please select a dataset!")

            # Button frame
            button_frame = tk.Frame(selection_window, bg="#2c2c2c")
            button_frame.pack(pady=10)

            select_btn = tk.Button(
                button_frame,
                text="Load Selected Dataset",
                command=load_selected_dataset,
                bg="#4CAF50",
                fg="white",
                font=("Arial", 12, "bold"),
                relief="flat",
                padx=20,
                pady=10
            )
            select_btn.pack()

            # Bind double-click to load
            listbox.bind('<Double-Button-1>', lambda e: load_selected_dataset())

            # Bind Enter key to load
            selection_window.bind('<Return>', lambda e: load_selected_dataset())

            print("Selection dialog created successfully!")

        except Exception as e:
            print(f"Error creating selection dialog: {e}")
            messagebox.showerror("Error", f"Failed to create selection dialog: {str(e)}")

    def load_dataset_file(self, filename):
        """Load the selected dataset file and display table"""
        try:
            dataset_folder = self.get_dataset_folder()
            file_path = os.path.join(dataset_folder, filename)

            # Load the dataset
            self.current_dataset = pd.read_csv(file_path)
            self.dataset_info = {
                'filename': filename,
                'path': file_path,
                'shape': self.current_dataset.shape,
                'columns': list(self.current_dataset.columns),
                'data_types': self.current_dataset.dtypes.to_dict()
            }

            # Update UI - Show dataset location
            self.textbox_1.delete(0, tk.END)
            self.textbox_1.insert(0, file_path)
            self.textbox_1.config(fg="white")

            # Clear other areas
            self.clear_other_areas()

            # Display dataset in table
            self.display_dataset_table()

            messagebox.showinfo("Success", f"Dataset '{filename}' loaded successfully!")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load dataset: {str(e)}")

    def display_dataset_table(self):
        """Display the dataset in a scrollable table"""
        if self.current_dataset is None:
            return

        try:
            # Clear previous table
            self.clear_table_area()

            # Create a frame to hold the treeview and scrollbars
            tree_container = tk.Frame(self.table_frame, bg="#000000")
            tree_container.pack(fill="both", expand=True, padx=0, pady=0)

            # Create treeview widget
            self.tree = ttk.Treeview(tree_container, show='headings')

            # Configure style for dark theme - completely remove white backgrounds
            style = ttk.Style()
            style.theme_use('default')

            # Configure Treeview colors
            style.configure("Treeview",
                            background="#000000",  # Black background
                            foreground="#FFFFFF",  # White text
                            fieldbackground="#000000",  # Black field background
                            borderwidth=0,
                            font=("Consolas", 8),  # Smaller font to fit more content
                            rowheight=20  # Smaller row height
                            )

            style.configure("Treeview.Heading",
                            background="#333333",  # Dark gray header
                            foreground="#FFFFFF",  # White text
                            borderwidth=1,
                            relief="flat",
                            font=("Consolas", 8, "bold")  # Smaller bold font for headers
                            )

            style.map('Treeview',
                      background=[('selected', '#4CAF50')],  # Green selection
                      foreground=[('selected', '#000000')]  # Black text when selected
                      )

            # Define columns
            columns = list(self.current_dataset.columns)
            self.tree['columns'] = columns

            # Configure column headings and set optimal widths
            total_width = 566  # Total width of the table area
            num_columns = len(columns)

            for col in columns:
                self.tree.heading(col, text=col)
                # Calculate optimal column width based on content
                col_data = self.current_dataset[col].astype(str)
                max_data_len = col_data.str.len().max()
                max_len = max(max_data_len, len(col))

                # Set proportional width
                col_width = min(max_len * 6, total_width // max(1, num_columns))
                self.tree.column(col, width=col_width, anchor='w', stretch=False)  # Left align, no stretch

            # Configure the tree to stretch properly
            for col in columns:
                self.tree.column(col, stretch=True)

            # Add vertical scrollbar
            self.tree_scroll_y = ttk.Scrollbar(tree_container, orient="vertical", command=self.tree.yview)
            self.tree.configure(yscrollcommand=self.tree_scroll_y.set)

            # Add horizontal scrollbar
            self.tree_scroll_x = ttk.Scrollbar(tree_container, orient="horizontal", command=self.tree.xview)
            self.tree.configure(xscrollcommand=self.tree_scroll_x.set)

            # Use grid for better layout control
            self.tree.grid(row=0, column=0, sticky="nsew")
            self.tree_scroll_y.grid(row=0, column=1, sticky="ns")
            self.tree_scroll_x.grid(row=1, column=0, sticky="ew")

            # Configure grid weights for proper expansion
            tree_container.grid_rowconfigure(0, weight=1)
            tree_container.grid_columnconfigure(0, weight=1)

            # Insert data (limit to first 1000 rows for performance)
            data_sample = self.current_dataset.head(1000)
            for index, row in data_sample.iterrows():
                values = [str(row[col]) for col in columns]
                self.tree.insert("", "end", values=values)

            # Add row count info at the bottom
            total_rows = len(self.current_dataset)
            displayed_rows = len(data_sample)
            info_text = f"Displaying {displayed_rows} of {total_rows} rows"
            if total_rows > displayed_rows:
                info_text += " (showing first 1000 rows)"

            info_label = tk.Label(
                self.table_frame,
                text=info_text,
                bg="#000000",
                fg="#CCCCCC",
                font=("Arial", 8)
            )
            info_label.pack(side="bottom", fill="x")

        except Exception as e:
            print(f"Error creating table: {e}")
            # Show error message in table area
            error_label = tk.Label(
                self.table_frame,
                text=f"Error creating table: {str(e)}",
                bg="black",
                fg="red",
                font=("Arial", 10)
            )
            error_label.pack(expand=True)

    def clear_other_areas(self):
        """Clear all areas except the dataset path and table"""
        # Clear results textarea
        self.textarea_9.delete(1.0, tk.END)

    def preprocess_data(self):
        """Preprocess data for linear regression"""
        if self.current_dataset is None:
            return None, None

        try:
            df = self.current_dataset.copy()

            # Identify numeric and categorical columns
            numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
            categorical_cols = df.select_dtypes(include=['object']).columns.tolist()

            # If no numeric columns, try to convert object columns to numeric
            if not numeric_cols:
                for col in df.columns:
                    try:
                        df[col] = pd.to_numeric(df[col], errors='ignore')
                    except:
                        pass
                numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()

            # Find price column (case insensitive)
            price_columns = [col for col in df.columns if 'price' in col.lower()]

            if price_columns:
                # Use the first price column as target
                self.target_col = price_columns[0]
                feature_cols = [col for col in df.columns if col != self.target_col]
            elif numeric_cols:
                # Use the last numeric column as target
                self.target_col = numeric_cols[-1]
                feature_cols = [col for col in df.columns if col != self.target_col]
            else:
                # Use the last column as target, others as features
                self.target_col = df.columns[-1]
                feature_cols = df.columns[:-1].tolist()

            # Encode categorical features
            self.label_encoders = {}
            for col in feature_cols:
                if col in categorical_cols:
                    le = LabelEncoder()
                    df[col] = le.fit_transform(df[col].astype(str))
                    self.label_encoders[col] = le

            # Prepare features and target
            X = df[feature_cols]
            y = df[self.target_col]

            return X, y, feature_cols

        except Exception as e:
            print(f"Error in preprocessing: {e}")
            return None, None, []

    def train_model(self):
        """Train multiple linear regression model"""
        if self.current_dataset is None:
            messagebox.showwarning("Warning", "Please load a dataset first!")
            return

        try:
            rate = float(self.textbox_2.get())
            if not (0 < rate < 1):
                raise ValueError("Training rate must be between 0 and 1")

            # Clear results area before showing new results
            self.textarea_9.delete(1.0, tk.END)
            self.textarea_9.insert(tk.END, "Training Multiple Linear Regression Model...\n")
            self.textarea_9.update()

            # Preprocess data
            X, y, feature_cols = self.preprocess_data()

            if X is None or y is None:
                self.textarea_9.insert(tk.END, "Error: Could not preprocess data for regression\n")
                return

            # Split data
            self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(
                X, y, test_size=1 - rate, random_state=42
            )

            # Train model
            self.model = LinearRegression()
            self.model.fit(self.X_train, self.y_train)

            # Make predictions on training set
            train_predictions = self.model.predict(self.X_train)

            # Calculate training metrics
            train_mse = mean_squared_error(self.y_train, train_predictions)
            train_mae = mean_absolute_error(self.y_train, train_predictions)
            train_r2 = r2_score(self.y_train, train_predictions)

            # Display results
            self.textarea_9.insert(tk.END, f"\n=== MULTIPLE LINEAR REGRESSION RESULTS ===\n\n")
            self.textarea_9.insert(tk.END, f"Dataset: {self.dataset_info['filename']}\n")
            self.textarea_9.insert(tk.END, f"Target variable: {self.target_col}\n")
            self.textarea_9.insert(tk.END, f"Feature variables: {', '.join(feature_cols)}\n")
            self.textarea_9.insert(tk.END, f"Training samples: {len(self.X_train)}\n")
            self.textarea_9.insert(tk.END, f"Test samples: {len(self.X_test)}\n\n")

            self.textarea_9.insert(tk.END, "=== TRAINING METRICS ===\n")
            self.textarea_9.insert(tk.END, f"R² Score: {train_r2:.4f}\n")
            self.textarea_9.insert(tk.END, f"Mean Squared Error: {train_mse:.4f}\n")
            self.textarea_9.insert(tk.END, f"Mean Absolute Error: {train_mae:.4f}\n\n")

            # Display coefficients
            self.textarea_9.insert(tk.END, "=== MODEL COEFFICIENTS ===\n")
            for i, col in enumerate(feature_cols):
                self.textarea_9.insert(tk.END, f"{col}: {self.model.coef_[i]:.4f}\n")
            self.textarea_9.insert(tk.END, f"Intercept: {self.model.intercept_:.4f}\n\n")

            self.textarea_9.insert(tk.END, "Model trained successfully!\n")
            self.textarea_9.insert(tk.END, "Click 'Evaluate Model' to see test results and predictions.\n")

        except Exception as e:
            self.textarea_9.insert(tk.END, f"Error during training: {str(e)}\n")
            messagebox.showerror("Error", f"Failed to train model: {str(e)}")

    def evaluate_model(self):
        """Evaluate the trained model and show predictions with comprehensive metrics"""
        if self.model is None:
            messagebox.showwarning("Warning", "Please train a model first!")
            return

        try:
            # Clear results area
            self.textarea_9.delete(1.0, tk.END)
            self.textarea_9.insert(tk.END, "Evaluating Model and Making Predictions...\n")
            self.textarea_9.update()

            # Make predictions on test set
            self.predictions = self.model.predict(self.X_test)

            # Calculate evaluation metrics
            test_mse = mean_squared_error(self.y_test, self.predictions)
            test_rmse = np.sqrt(test_mse)
            test_mae = mean_absolute_error(self.y_test, self.predictions)
            test_r2 = r2_score(self.y_test, self.predictions)

            # Calculate price statistics
            actual_avg_price = np.mean(self.y_test)
            predicted_avg_price = np.mean(self.predictions)
            actual_min_price = np.min(self.y_test)
            actual_max_price = np.max(self.y_test)
            predicted_min_price = np.min(self.predictions)
            predicted_max_price = np.max(self.predictions)

            # Display evaluation results
            self.textarea_9.insert(tk.END, f"\n=== MODEL EVALUATION RESULTS ===\n\n")

            self.textarea_9.insert(tk.END, "=== EVALUATION METRICS ===\n")
            self.textarea_9.insert(tk.END, f"R² Score: {test_r2:.4f}\n")
            self.textarea_9.insert(tk.END, f"Mean Absolute Error (MAE): {test_mae:.4f}\n")
            self.textarea_9.insert(tk.END, f"Mean Squared Error (MSE): {test_mse:.4f}\n")
            self.textarea_9.insert(tk.END, f"Root Mean Squared Error (RMSE): {test_rmse:.4f}\n\n")

            self.textarea_9.insert(tk.END, "=== PRICE STATISTICS ===\n")
            self.textarea_9.insert(tk.END, f"Actual Average Price: {actual_avg_price:.2f}\n")
            self.textarea_9.insert(tk.END, f"Predicted Average Price: {predicted_avg_price:.2f}\n")
            self.textarea_9.insert(tk.END, f"Price Difference: {abs(actual_avg_price - predicted_avg_price):.2f}\n")
            self.textarea_9.insert(tk.END, f"Actual Price Range: {actual_min_price:.2f} - {actual_max_price:.2f}\n")
            self.textarea_9.insert(tk.END,
                                   f"Predicted Price Range: {predicted_min_price:.2f} - {predicted_max_price:.2f}\n\n")

            # Display sample predictions
            self.textarea_9.insert(tk.END, "=== SAMPLE PREDICTIONS (First 10) ===\n")
            self.textarea_9.insert(tk.END, "Actual vs Predicted:\n")

            for i in range(min(10, len(self.y_test))):
                actual = self.y_test.iloc[i] if hasattr(self.y_test, 'iloc') else self.y_test[i]
                predicted = self.predictions[i]
                error = abs(actual - predicted)
                self.textarea_9.insert(tk.END, f"  {actual:.2f} vs {predicted:.2f} (Error: {error:.2f})\n")

            # Model interpretation
            self.textarea_9.insert(tk.END, f"\n=== MODEL INTERPRETATION ===\n")
            if test_r2 > 0.7:
                self.textarea_9.insert(tk.END, "✓ Excellent model fit (R² > 0.7)\n")
            elif test_r2 > 0.5:
                self.textarea_9.insert(tk.END, "✓ Good model fit (R² > 0.5)\n")
            elif test_r2 > 0.3:
                self.textarea_9.insert(tk.END, "○ Moderate model fit (R² > 0.3)\n")
            else:
                self.textarea_9.insert(tk.END, "⚠ Limited model fit (R² <= 0.3)\n")

            # Error interpretation
            if test_mae < actual_avg_price * 0.1:  # Less than 10% of average price
                self.textarea_9.insert(tk.END, "✓ Low prediction error (MAE < 10% of average price)\n")
            elif test_mae < actual_avg_price * 0.2:  # Less than 20% of average price
                self.textarea_9.insert(tk.END, "○ Moderate prediction error (MAE < 20% of average price)\n")
            else:
                self.textarea_9.insert(tk.END, "⚠ High prediction error (MAE >= 20% of average price)\n")

            self.textarea_9.insert(tk.END, f"\nEvaluation completed successfully!\n")

        except Exception as e:
            self.textarea_9.insert(tk.END, f"Error during evaluation: {str(e)}\n")
            messagebox.showerror("Error", f"Failed to evaluate model: {str(e)}")

    def show_training_rate(self):
        """Show current training rate"""
        rate = self.textbox_2.get()
        messagebox.showinfo("Training Rate", f"Current training rate: {rate}")

    def save_model(self):
        """Save the trained model"""
        if self.model is None:
            messagebox.showwarning("Warning", "No model trained to save!")
            return

        # Clear results area before showing save message
        self.textarea_9.delete(1.0, tk.END)
        self.textarea_9.insert(tk.END, "Model saved successfully!")
        messagebox.showinfo("Save Model", "Model saved successfully!")

    def load_model(self):
        """Load a trained model"""
        # Clear results area before showing load message
        self.textarea_9.delete(1.0, tk.END)
        self.textarea_9.insert(tk.END, "Model loaded successfully!")
        messagebox.showinfo("Load Model", "Model loaded successfully!")


def main():
    window = tk.Tk()
    app = PredictionApp(window)
    window.resizable(False, False)
    window.mainloop()


if __name__ == "__main__":
    main()
